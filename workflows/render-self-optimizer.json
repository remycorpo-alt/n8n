{
  "name": "Render Self-Optimizer",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 10
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Run Every 10 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 0]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.render.com/v1/services/YOUR_SERVICE_ID/deploys?limit=1",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "get-deploy-status",
      "name": "Get Deploy Status",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-failed",
              "leftValue": "={{ $json[0].deploy.status }}",
              "rightValue": "live",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-status",
      "name": "Deploy Failed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [440, 0]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.render.com/v1/services/YOUR_SERVICE_ID/logs?tail=100",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "get-error-logs",
      "name": "Get Error Logs",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [660, -200]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.github.com/repos/YOUR_GITHUB_USERNAME/n8n/contents/Dockerfile?ref=YOUR_BRANCH",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "get-dockerfile",
      "name": "Get Dockerfile",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [660, -50]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://api.github.com/repos/YOUR_GITHUB_USERNAME/n8n/contents/render.yaml?ref=YOUR_BRANCH",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "get-render-yaml",
      "name": "Get render.yaml",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [660, 100]
    },
    {
      "parameters": {
        "jsCode": "// Get data from previous nodes\nconst deployStatus = $('Get Deploy Status').json[0].deploy.status;\nconst isError = deployStatus !== 'live';\nconst errorLogs = isError ? $('Get Error Logs').json : [];\n\n// Decode base64 file contents\nconst dockerfileB64 = $('Get Dockerfile').json.content;\nconst renderYamlB64 = $('Get render.yaml').json.content;\n\nconst dockerfile = Buffer.from(dockerfileB64, 'base64').toString('utf8');\nconst renderYaml = Buffer.from(renderYamlB64, 'base64').toString('utf8');\n\n// Get file SHAs for later update\nconst dockerfileSha = $('Get Dockerfile').json.sha;\nconst renderYamlSha = $('Get render.yaml').json.sha;\n\n// Get optimization history from workflow static data\nconst staticData = $getWorkflowStaticData('global');\nconst optimizationHistory = staticData.optimizationHistory || [];\nconst lastOptimization = staticData.lastOptimization || 'none';\nconst tokensExhausted = staticData.tokensExhausted || false;\nconst pausedUntil = staticData.pausedUntil || 0;\n\n// Check if we should skip due to rate limit\nconst now = Date.now();\nif (pausedUntil > now) {\n  return { skip: true, reason: 'Rate limited, waiting...', resumeIn: Math.round((pausedUntil - now) / 1000) + ' seconds' };\n}\n\nreturn {\n  skip: false,\n  isError: isError,\n  deployStatus: deployStatus,\n  errorLogs: JSON.stringify(errorLogs),\n  dockerfile: dockerfile,\n  renderYaml: renderYaml,\n  dockerfileSha: dockerfileSha,\n  renderYamlSha: renderYamlSha,\n  optimizationHistory: optimizationHistory,\n  lastOptimization: lastOptimization\n};"
      },
      "id": "prepare-data",
      "name": "Prepare Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "skip-check",
              "leftValue": "={{ $json.skip }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "should-skip",
      "name": "Should Skip?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [1100, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-sonnet-4-20250514\",\n  \"max_tokens\": 4096,\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"You are optimizing an n8n deployment on Render. \" + ($json.isError ? \"CRITICAL: The deployment has FAILED. Fix the error first.\\n\\nError Logs:\\n\" + $json.errorLogs : \"The deployment is running. Look for optimizations.\") + \"\\n\\nCurrent Dockerfile:\\n\" + $json.dockerfile + \"\\n\\nCurrent render.yaml:\\n\" + $json.renderYaml + \"\\n\\nPrevious optimizations applied: \" + JSON.stringify($json.optimizationHistory) + \"\\n\\nLast optimization: \" + $json.lastOptimization + \"\\n\\nRules:\\n1. If there's an error, FIX IT FIRST\\n2. If no error, suggest ONE optimization (performance, security, best practices)\\n3. If nothing left to optimize, respond with OPTIMIZATION_COMPLETE\\n4. Don't repeat previous optimizations\\n\\nRespond in this exact JSON format only:\\n{\\n  \\\"status\\\": \\\"error_fix\\\" or \\\"optimization\\\" or \\\"complete\\\",\\n  \\\"analysis\\\": \\\"brief explanation\\\",\\n  \\\"file_to_update\\\": \\\"Dockerfile\\\" or \\\"render.yaml\\\" or \\\"none\\\",\\n  \\\"new_content\\\": \\\"complete file content if updating, empty string if complete\\\",\\n  \\\"optimization_name\\\": \\\"short name for this change\\\"\\n}\"\n    }\n  ]\n}",
        "options": {}
      },
      "id": "ask-claude",
      "name": "Ask Claude",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1320, 100]
    },
    {
      "parameters": {
        "jsCode": "const response = $('Ask Claude').json;\n\n// Check for rate limit error\nif (response.error && response.error.type === 'rate_limit_error') {\n  const staticData = $getWorkflowStaticData('global');\n  staticData.tokensExhausted = true;\n  staticData.pausedUntil = Date.now() + (60 * 60 * 1000); // Pause for 1 hour\n  return { action: 'rate_limited', message: 'Token limit reached. Will resume in 1 hour.' };\n}\n\n// Parse Claude's response\nlet parsed;\ntry {\n  const text = response.content[0].text;\n  const match = text.match(/\\{[\\s\\S]*\\}/);\n  parsed = JSON.parse(match ? match[0] : text);\n} catch(e) {\n  return { action: 'error', message: 'Failed to parse Claude response: ' + e.message };\n}\n\n// Update static data with optimization history\nconst staticData = $getWorkflowStaticData('global');\nstaticData.tokensExhausted = false;\nstaticData.pausedUntil = 0;\n\nif (parsed.status === 'complete') {\n  staticData.optimizationComplete = true;\n  return { action: 'complete', message: 'All optimizations done!', analysis: parsed.analysis };\n}\n\n// Add to optimization history\nif (!staticData.optimizationHistory) staticData.optimizationHistory = [];\nstaticData.optimizationHistory.push(parsed.optimization_name);\nstaticData.lastOptimization = parsed.optimization_name;\n\n// Get the right SHA\nconst prepData = $('Prepare Data').json;\nconst sha = parsed.file_to_update === 'Dockerfile' ? prepData.dockerfileSha : prepData.renderYamlSha;\n\nreturn {\n  action: parsed.status,\n  analysis: parsed.analysis,\n  file_to_update: parsed.file_to_update,\n  new_content_b64: Buffer.from(parsed.new_content).toString('base64'),\n  sha: sha,\n  commit_message: (parsed.status === 'error_fix' ? 'Fix: ' : 'Optimize: ') + parsed.optimization_name\n};"
      },
      "id": "parse-response",
      "name": "Parse & Track",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 100]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "needs-update",
              "leftValue": "={{ $json.action }}",
              "rightValue": "complete",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            },
            {
              "id": "not-rate-limited",
              "leftValue": "={{ $json.action }}",
              "rightValue": "rate_limited",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            },
            {
              "id": "not-error",
              "leftValue": "={{ $json.action }}",
              "rightValue": "error",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "should-update",
      "name": "Should Update?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.1,
      "position": [1760, 100]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=https://api.github.com/repos/YOUR_GITHUB_USERNAME/n8n/contents/{{ $json.file_to_update }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"message\": \"{{ $json.commit_message }}\\n\\nhttps://claude.ai/autofix\",\n  \"content\": \"{{ $json.new_content_b64 }}\",\n  \"sha\": \"{{ $json.sha }}\",\n  \"branch\": \"YOUR_BRANCH\"\n}",
        "options": {}
      },
      "id": "push-to-github",
      "name": "Push to GitHub",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1980, 0]
    },
    {
      "parameters": {
        "content": "## Render Self-Optimizer\n\nThis workflow:\n1. Checks Render status every 10 min\n2. If error → Claude fixes it\n3. If running → Claude optimizes\n4. Pushes changes to GitHub\n5. Tracks what's been done\n6. Stops when fully optimized\n7. Handles rate limits\n\n## Setup\n\nReplace:\n- YOUR_SERVICE_ID → srv-xxx\n- YOUR_GITHUB_USERNAME → your username\n- YOUR_BRANCH → main or your branch\n\n## Credentials\n\n- Render API (Header Auth)\n- GitHub API (Header Auth)\n- Anthropic API (Header Auth)",
        "height": 400,
        "width": 300
      },
      "id": "sticky-note",
      "name": "Instructions",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-350, -150]
    }
  ],
  "connections": {
    "Run Every 10 Minutes": {
      "main": [
        [
          {
            "node": "Get Deploy Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Deploy Status": {
      "main": [
        [
          {
            "node": "Deploy Failed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deploy Failed?": {
      "main": [
        [
          {
            "node": "Get Error Logs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Dockerfile",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get render.yaml",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Dockerfile",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get render.yaml",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Error Logs": {
      "main": [
        [
          {
            "node": "Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Dockerfile": {
      "main": [
        [
          {
            "node": "Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get render.yaml": {
      "main": [
        [
          {
            "node": "Prepare Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Data": {
      "main": [
        [
          {
            "node": "Should Skip?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Skip?": {
      "main": [
        [
        ],
        [
          {
            "node": "Ask Claude",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ask Claude": {
      "main": [
        [
          {
            "node": "Parse & Track",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Track": {
      "main": [
        [
          {
            "node": "Should Update?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Update?": {
      "main": [
        [
          {
            "node": "Push to GitHub",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {
    "global": {
      "optimizationHistory": [],
      "lastOptimization": "none",
      "optimizationComplete": false,
      "tokensExhausted": false,
      "pausedUntil": 0
    }
  }
}
